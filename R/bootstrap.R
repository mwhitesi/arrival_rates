# Name: bootstrap.R
# Desc: Compute standard error estimates for parameters generated by modelling
# Author: Matt Whiteside
# Date: Nov 20, 2018

source('R/packages.R')
source('R/tsregression.R')
source('R/shifts.R')
source('R/queuemodel.R')
library('tseries')

# Parameters
duration.in.min = 15
pred.intv = 0.991
Reps = 1000

# Load required data
demand = drake::readd(demand)

# Remove first/last day
setkey(demand, window)
demand = shifts$trim(demand)
start.ts = min(demand$window)
end.ts = max(demand$window)


# Comments about time series bootstrapping
# Our data has strong seasonality - weekly and daily patterns that should be captured in samples
# For this reason, I use a custom sampling method that samples random week-long blocks from the dataset.
# I mostly ignore the stationality and trend component of the time series. (i.e. blocks are short and do not ensure long term trend
# is maintained, I also reorder weekly blocks to ensure the same day of week order is maintained in each sample, so weekly block order
# is not preserved)


# Compute model and performance
f <- function(boot.sample, pi) {
  
  # Build weekly demand model
  modU = tsregression__fitFFTModel(boot.sample, duration.in.min, pi)
  
  # Add datetime column
  modU = queuemodel__convert(modU)
  setkey(modU, window)
  
  # Stretch weekly values to year
  modU = shifts$fill(modU, start.ts, end.ts)
  
  # Join to actual demand
  modDT = shifts$shift_join(modU, demand)
  
  # Compute performance
  res = shifts$performance(modDT)

  return(res)
}

mod <- function(i, n) {
  1 + (i - 1) %% n
}

reorder <- function(i, demand) {
  d1 = demand[i,]
  setorderv(d1, c('weekly.bin', 'daily.bin'), c(1,1))
  d1
}

dboot <- function(demand, b) {
  
  m <- nrow(demand)
  nn <- ceiling(m / b)
  lens <- c(rep(b, nn - 1L), 1L + (m - 1L) %% b)
  st <- sample.int(m, nn, replace = TRUE)
  bs = rbindlist(purrr::map2(st, lens, 
                             function(s, l) { 
                               i = as.integer(mod(seq(s, s + l - 1L), m))
                               d1 = reorder(i, demand)
                             }))
  bs[,window := demand$window]
  return(bs)
}

dbootstrap <- function(demand, R, b) {
  tibble(sample = purrr::rerun(R, dboot(demand, b)), .id = seq_len(R))
}

# Generate bootstrap samples
samples = dbootstrap(demand, Reps, 7*24*60/duration.in.min)

# Generate models and performance
res = lapply(samples %>% pull(sample), f, pred.intv)

# Compute original dataset values
orig = f(demand, pred.intv)

# Compute standard error and bias for metrics of interest
dboot_se <- function(orig, bs) {
  
  return(list(bias = mean(bs) - orig,
              se = sd(bs)
  ))
}

dboot_hist <- function(orig, bs, label='value') {
  
  bw <- (2 * IQR(bs)) / length(bs)^(1/3)
  p = ggplot(data.frame(value=bs), aes(x=value)) + 
    geom_histogram(binwidth = bw) +
    geom_vline(xintercept = orig, linetype="dashed", 
               color = "red", size=1.2) +
    theme_bw() +
    xlab(paste0(label, ' Sample Value')) +
    annotate('text', x=orig, y=1, label='Original Value', color='red') +
    ggtitle(paste0('Bootstrap Distribution for ', label))
  
  return(p)
    
}

dboot_se(orig[['UnitAvailableProportion']], sapply(res, `[[`, 'UnitAvailableProportion'))


# Generate plots of estimates
p = dboot_hist(orig[['UnitAvailableProportion']], sapply(res, `[[`, 'UnitAvailableProportion'), 'Unit Availability Proportion')

ggsave('data/interim/unit_availability_proportion_bootstrap_histogram.pdf', p, width=8, height=8)

# Plot samples
sliding.window = function(x) rollapply(x, width = 48, by = 48, FUN = mean, na.rm = TRUE, align = "left")
samples.rolling = cbind(demand[,sliding.window(count)], 
      sapply(samples %>% slice(sample.int(nrow(samples), 10, replace = FALSE)) 
       %>% pull(sample), function(dt) dt[, sliding.window(count)]))

samples.rolling = data.table(window=seq(demand$window[1], length.out = nrow(samples.rolling), by=paste(duration.in.min, 'min')), samples.rolling)


sample.rollmeans = cbind(demand[,.(window, rolling=rollmean(count, k=47, fill=NA))], 
                         data.frame(sapply(samples %>% pull(sample), rollmean, k=47, fill=NA)))

sample.rollmeans %>%  gather(key, value, -window, -rolling) %>%

demand %>% ggplot(aes(x=window, y=count)) +
  geom_line()



x.min = min(window.counts[,window])
p = window.counts %>% gather(metric,value,c(count,daily.median,weekly.median)) %>%

# Check optimum number of regression terms for bootstrap samples, does it change?

samples

tsregression__FFTModelAICc(demand, duration.in.min, pred.intv)

# Check fit of original model on bootstrapped samples

